class String
  def initialize(ptr: Shiika::Internal::Ptr, bytesize: Int)
    @ptr = ptr
    # Number of bytes of the content (does not include the last null)
    @bytesize = bytesize
  end

  # Return true if `self` and `other` has same contents
  def ==(other: String) -> Bool
    if @bytesize != other.bytesize
      false
    else
      var ret = true
      var i = 0; while i < @bytesize
        if self.nth_byte(i) != other.nth_byte(i)
          ret = false
        end
        i += 1
      end
      ret
    end
  end

  def ptr -> Shiika::Internal::Ptr
    @ptr
  end

  def bytesize -> Int
    @bytesize
  end

  # Call `f` for each byte
  def each_byte(f: Fn1<Int, Void>) 
    var i = 0; while i < @bytesize
      f.call(self.nth_byte(i))
      i += 1
    end

    # TODO #194
    #@bytesize.times do |i: Int|
    #  f.call(self.nth_byte(i))
    #end
  end

  def +(other: String) -> String
    ret = MutableString.new
    ret.append(self)
    ret.append(other)
    ret._unsafe_to_s
  end

  def inspect -> String
    # TODO: format newline, etc.
    "\"" + self + "\""
  end

  def nth_byte(i: Int) -> Int
    if i < 0
      panic "[String#nth_byte: index less than zero]"
    end
    if i >= @bytesize
      panic "[String#nth_byte: index too large]"
    end
    (@ptr+i).read
  end

  # Create a string which has a partial content of `self`
  def slice_bytes(from: Int, bytes: Int) -> String
    if from < 0
      panic "[String#slice_bytes: `from` is less than zero]"
    end
    if from + bytes > @bytesize
      panic "[String#slice_bytes: `from + bytes` too large]"
    end
    newptr = Shiika::Internal::Memory.gc_malloc(bytes+1)
    Shiika::Internal::Memory.memcpy(newptr, @ptr+from, bytes)
    String.new(newptr, bytes)
  end

  # Split `self` with separator
  def split(sep: String) -> Array<String>
    if sep.bytesize == 0
      [self]
    else
      ret = Array<String>.new
      var word_start = 0
      var sep_cur = 0
      var i = 0
      while i < @bytesize
        if self.nth_byte(i) == sep.nth_byte(sep_cur)
          sep_cur += 1
          if sep_cur == sep.bytesize
            # Found a separator.
            ret.push(self.slice_bytes(word_start, i - word_start - sep.bytesize + 1))
            word_start = i + 1
            sep_cur = 0
          end
          0 # TODO: #184
        else
          # Not a separator here
          sep_cur = 0
        end
        i += 1
      end
      # The last part
      if word_start < @bytesize
        ret.push(self.slice_bytes(word_start, @bytesize - word_start))
      end

      ret
    end
  end

  # Parse `self` as an integer value.
  # If non-digit character appears, parsing is terminated.
  def to_i -> Int
    var n = 0
    # TODO: Use each_byte (#177)
    var i = 0; while i < @bytesize
      b = self.nth_byte(i)
      if 48 <= b && b <= 57
        n *= 10
        n += b - 48
      end
      if b < 48 || b > 57
        break
      end
      i += 1
    end

    n
  end

  def to_s -> String
    self
  end
end
