class Array<T>
  BYTES_OF_PTR = 8  # Assuming 64bit env
  INITIAL_CAPA = 10

  def initialize
    var @capa = INITIAL_CAPA
    var @n_items = 0
    var @items = Shiika::Internal::Memory.gc_malloc(BYTES_OF_PTR * INITIAL_CAPA)
  end

  # Return the `i`th item
  # Panics if the index is out of range
  def [](i: Int) -> T
    if i < 0
      panic "[Array#[]: index less than zero]"
    end
    if i >= @n_items
      panic "[Array#[]: index too large]"
    end
    (@items + i * BYTES_OF_PTR).load 
  end

  # Replace the `i`th item with `obj`
  # Panics if the index is out of range
  def []=(i: Int, obj: T)
    if i < 0
      panic "[Array#[]=: index less than zero]"
    end
    if i >= @n_items
      panic "[Array#[]=: index too large]"
    end
    (@items + i * BYTES_OF_PTR).store(obj) 
  end

  # Add elements of `other` to the end of `self`
  def append(other: Array<T>)
    other.each do |item: T|
      push(item)
    end
  end

  # Remove all elements of `self`
  def clear
    @n_items = 0
    # QUESTION: should we call gc_realloc?
  end

  # Create shallow clone of `self`
  def clone -> Array<T>
    ret = Array<T>.new
    each do |item: T|
      ret.push(item)
    end
    ret
  end

  # Call `f` with each element of `self`
  def each(f: Fn1<T, Void>)
    var i = 0; while i < @n_items
      f.call(self[i])
      i += 1
    end
  end

  # Return the first element
  def first -> T  # TODO: Return Option
    ptr = @items
    ptr.load
  end

  # Return true if `self` contains `item` (compared by `==`)
  def includes(item: T) -> Bool
    var ret = false
    each do |x: T|
      if x == item; ret = true; end
    end
    ret
  end

  # Return string representation of `self` (for debugging)
  def inspect -> String
    var first = true
    ret = MutableString.new
    ret.append("[")
    each do |item: T|
      if first
        first = false
      else
        ret.append(", ")
      end
      ret.append(item.inspect)
    end
    ret.append("]")
    ret._unsafe_to_s
  end

  # Return true if `self` has no elements
  def is_empty -> Bool
    @n_items == 0
  end

  # Return true if `f` returned true for all items
  def is_all(f: Fn1<T, Bool>) -> Bool
    var ret = true
    each do |x: T|
      unless f.call(x); ret = false; end
    end
    ret
  end

  # Create a string by joining all items with separator.
  def join(separator: String) -> String
    var first = true
    ret = MutableString.new
    each do |item: T|
      if first
        first = false
      else
        ret.append(separator)
      end
      ret.append(item.to_s)
    end
    ret._unsafe_to_s
  end

  # TODO: return Option
  def last -> T
    if @n_items == 0
      panic "[Array#last: array is empty]"
    end
    self[@n_items - 1]
  end

  # Return the number of items
  def length -> Int
    @n_items
  end

  # Remove the last element and return it
  def pop -> T
    if @n_items == 0
      panic "[Array#pop: array is empty]"
    end
    ret = self[@n_items-1]
    @n_items -= 1
    ret
  end

  # Push an object to the end of `self`
  def push(value: T)
    if @n_items == @capa
      if @capa < 1024
        @capa *= 2
      else
        @capa += 256
      end
      @items = Shiika::Internal::Memory.gc_realloc(@items, BYTES_OF_PTR * @capa + 1)
    end
    ptr = @items + @n_items * BYTES_OF_PTR
    ptr.store(value)
    @n_items += 1
  end

  # Create a new array which has reversed elements of `self`
  def reverse -> Array<T>
    ret = Array<T>.new
    reverse_each do |item: T|
      ret.push(item)
    end
    ret
  end

  # Call `f` with each element of `self` in the reversed order
  def reverse_each(f: Fn1<T, Void>)
    var i = @n_items - 1; while i >= 0
      f.call(self[i])
      i -= 1
    end
  end

  # Create sorted version of `self`
  # Panics if `T` does not implement `==` and `<`
  def sort -> Array<T>
    ret = self.clone
    ret.sort_inplace
    ret
  end

  # Destructively sort elements of `self`.
  # Panics if `T` does not implement `==` and `<`
  def sort_inplace()
    if self.is_empty
      # do nothing
    else
      _quicksort(0, @n_items - 1)
    end
  end
  def _quicksort(i: Int, j: Int)
    if i == j
      # done
    else
      k = _partition(i, j, self[_choose_pivot(i, j)])
      _quicksort(i, k-1)
      _quicksort(k, j)
    end
  end
  def _choose_pivot(i: Int, j: Int) -> Int
    var k = i + 1
    while k <= j && self[i] == self[k]
      k += 1
    end
    if k > j
      -1
    elsif self[i] >= self[k]
      i
    else
      k
    end
  end
  def _partition(i: Int, j: Int, pivot: T) -> Int
    var l = i
    var r = j
    while l <= r
      while l <= j && self[l] < pivot
        l += 1
      end
      while r >= i && self[r] >= pivot
        r -= 1
      end
      if l > r
        #break  # #215
      else
        tmp = self[l]
        self[l] = self[r]
        self[r] = tmp
        l += 1
        r -= 1
      end
    end
    l
  end
end

# Create `Meta:Array` by this ConstRef for array literals (#178)
Array
