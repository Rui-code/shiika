# TODO: Move to Array::
BYTES_OF_PTR = 8  # Assuming 64bit env
INITIAL_CAPA = 10

class Array<T>
  def initialize
    var @capa = INITIAL_CAPA
    var @n_items = 0
    var @items = Shiika::Internal::Memory.gc_malloc(BYTES_OF_PTR * INITIAL_CAPA)
  end

  # Add elements of `other` to the end of `self`
  def append(other: Array<T>)
    other.each do |item: T|
      push(item)
    end
  end

  # Remove all elements of `self`
  def clear
    @n_items = 0
    # QUESTION: should we call gc_realloc?
  end

  # Call `f` with each element of `self`
  def each(f: Fn1<T, Void>)
    var i = 0; while i < @n_items
      f.call(self[i])
      i += 1
    end
  end

  # Return the first element
  def first -> T  # TODO: Return Option
    ptr = @items
    ptr.load
  end

  # Return true if `self` contains `item` (compared by `==`)
  def includes(item: T) -> Bool
    var ret = false
    each do |x: T|
      if x == item; ret = true; end
    end
    ret
  end

  # Return string representation of `self` (for debugging)
  def inspect -> String
    var first = true
    ret = MutableString.new
    ret.append("[")
    each do |item: T|
      if first
        first = false
      else
        ret.append(", ")
      end
      ret.append(item.inspect)
    end
    ret.append("]")
    ret._unsafe_to_s
  end

  # Return true if `self` has no elements
  def is_empty -> Bool
    @n_items == 0
  end

  # Return true if `f` returned true for all items
  def is_all(f: Fn1<T, Bool>) -> Bool
    var ret = true
    each do |x: T|
      unless f.call(x); ret = false; end
    end
    ret
  end

  # Create a string by joining all items with separator.
  def join(separator: String) -> String
    var first = true
    ret = MutableString.new
    each do |item: T|
      if first
        first = false
      else
        ret.append(separator)
      end
      ret.append(item.to_s)
    end
    ret._unsafe_to_s
  end

  # Return the number of items
  def length -> Int
    @n_items
  end

  # Remove the last element and return it
  def pop -> T
    if @n_items == 0
      panic "[Array#pop: array is empty]"
    end
    ret = self[@n_items-1]
    @n_items -= 1
    ret
  end

  # Push an object to the end of `self`
  def push(value: T)
    if @n_items == @capa
      if @capa < 1024
        @capa *= 2
      else
        @capa += 256
      end
      @items = Shiika::Internal::Memory.gc_realloc(@items, BYTES_OF_PTR * @capa + 1)
    end
    ptr = @items + @n_items * BYTES_OF_PTR
    ptr.store(value)
    @n_items += 1
  end

# TODO: #205
#  # Create a new array which has reversed elements of `self`
#  def reverse -> Array<T>
#    ret = Array<T>.new
#    reverse_each do |item: T|
#      ret.push(item)
#    end
#    ret
#  end

  # Call `f` with each element of `self` in the reversed order
  def reverse_each(f: Fn1<T, Void>)
    var i = @n_items - 1; while i >= 0
      f.call(self[i])
      i -= 1
    end
  end

  # Return the `i`th item
  # Panics if the index is out of range
  def [](i: Int) -> T
    if i < 0
      panic "[Array#[]: index less than zero]"
    end
    if i >= @n_items
      panic "[Array#[]: index too large]"
    end
    (@items + i * BYTES_OF_PTR).load 
  end
end

# Create `Meta:Array` by this ConstRef for array literals (#178)
Array
